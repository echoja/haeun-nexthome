---
title: "운영체제 프로세스 메모리에 불연속적으로 할당하기"
date: 2022-03-07 10:00
tags:
- 운영체제
description: 페이징 테이블과 다단계 페이징 기법, 세그멘테이션 기법을 알아본다. 
---

지난번에 사용자 프로세스를 메모리에 연속적으로 올리는 방법을 배웠다.  
프로그램을 연속적으로 메모리에 할당하게 되면 시작 논리 메모리 주소만 알면 실제 물리 메모리의 주소로 변환하기 아주 쉬웠다.  
이번엔 메모리를 나눠 피지컬 메모리에 불연속으로 할당하는 기법을 배워본다.

## 불연속 할당

### segmentation: 프로그램을 의미있는 단위별로 자름

- 코드/데이터/스택 세그먼트로 나누거나 더 잘게 자를 수도 있음.
- 크기가 균일하지 않아 dynamic storage allocation problem 문제 일어남

### 페이징: 프로세스의 virtual memory를 같은 크기로 잘라 페이지 단위로 나눔

![페이징 기법 설명](/images/os/osmm6.png)

- 가상 메모리의 내용이 페이지 단위로 **불연속적** 으로 저장됨
- hole의 크기가 균일하지 않은 것을 걱정할 필요 없음
- 주소 바인딩(변환)을 페이지별로 해야함/ 일부는 backing storage에, 일부는 피지컬 메모리에 저장.

### 페이징 테이블

![페이징 예시](/images/os/osmm8.png)

- 각각의 프로세스별로 존재하며/ 논리 메모리가 물리적 메모리의 어느 부분에 들어가 있는가를 매핑해둔 테이블
- 3번 페이지는 7번 프레임에 들어가있다. (페이징 프레임: 페이지가 들어가있는 공간)
- 페이지 테이블은 메인 메모리에 상주.

![페이징 예시](/images/os/osmm10.png)

- Page-table base register (PTBR)가 페이지 테이블을 가리킴
- Page-table limit register (PTLR)가 테이블 크기를 보관
- 모든 메모리 접근 연산에는 2번의 메모리 액세스가 필요 (페이지 테이블 접근 1번, 실제 데이터/명령어 접근 1번)
- 속도 향상을 위해 associative register(TLB) 사용
  
#### TLB (Translation Look-aside Buffer)

- 주소 변환을 위한 **캐시** 메모리. 고속의 lookup hardware cache!
- 페이징 테이블의 일부 (자주 조회되는 주소)를 저장
- 병렬 검색. tlb에 없으면 TLB Miss 라고 함.
- TLB의 전체를 검색해봐도 없으면 메인 메모리에 있는 page table에서 프레임 번호를 얻음.
- TLB는 컨텍스트 스위칭 때 flush

## 2단계 페이지 테이블

![2단계 페이징](/images/os/osmm11.png)

### 왜 필요한가?

- 현대의 컴퓨터는 주소 공간이 매우 넓은 프로그램을 지원한다. 그러나 대부분의 프로그램이 그 주소공간 중 일부만 사용하므로 페이지 테이블 공간이 심하게 낭비된다.

### 해결 방법

- 페이지 테이블 자체를 페이지로 구성 (다단계 페이징 기법)
- 사용하지 않는 주소 공간에 대한 외부 페이지 테이블은 NULL로 설정해 대응하는 내부 페이지 테이블을 생성X
- 페이지 테이블을 두단계 거침. 속도가 빨라지진 않지만 페이지 테이블을 위한 공간이 줄어듦
- 메모리 공간은 결국 적게 쓰지만 페이지 테이블의 수가 증가하므로 시간이 소요됨 (tradeoff)  

![2단계 페이징](/images/os/osmm7.png)

- 논리 주소: P1(외부 페이지 테이블 인덱스) + P2(내부 페이지 테이블 인덱스) + d(페이지 오프셋)
- 최종 물리 메모리 주소: 외부 페이지 tb에서 P1만큼 떨어진 주소에서 내부 페이지 테이블 주소 얻고 여기서 P2만큼 떨어진 위치에서 페이지 프레임 위치를 얻은 후 해당 프레임에서 d만큼 떨어진 곳


지금까진 메모리 관리하는 법(Memory Management)을 배우면서 CPU가 주는 논리 메모리 주소를 물리 주소로 바꾸는 방법을 배우고 있다.
그 중에서도 불연속 분할 방법인 페이징을 배웠다.
이번엔 단계를 여럿으로 나눠 페이징을 하는 방법에서부터 시작한다!

## 다단계 페이징

- 주소 공간이 커지면 다단계 페이지 테이블 필요
- TLB(주소 변환 돕는 캐시 메모리)로 메모리 접근 시간을 줄일 수 있음

![4단계 페이지 테이블 사용하는 경우 예시](/images/os/mm1.png)

## 페이지 테이블의 Valid, Invalid 비트

![valid, invalid bits](/images/os/mm2.png)

- 페이지 테이블 엔트리에는 사용되지 않는 비트여도 페이지 테이블을 만들어둔다.
- 테이블이라는 자료구조 특성상 위에서부터 천천히 접근하기 때문에 다 만들지만 사용을 안 하므로 i로 표시
- 0번 페이지가 2번 프레임에 있다.

## 메모리 보호

![protection bit](/images/os/mm3.png)

- 페이지 테이블의 각 엔트리마다 protection 비트와 Valid-invalid 비트가 있다.
- protection bit: 페이지 접근 권한

## 지금까지의 문제

- 페이지 테이블의 큰 용량
- 페이지에 메모리가 없어도 프로세스별로 모든 논리 주소에 대응하는 모든 페이지에 대해 페이지 테이블 엔트리를 만들어야함.

## Inverted Page Table (역방향 페이지 테이블)

![역방향 페이지 테이블 그림](/images/os/mm4.png)

- 시스템에 하나의 페이지 테이블만 존재.
- 페이지 프레임 하나당 하나의 페이지 테이블 엔트리 / 페이지테이블 엔트리가 물리메모리의 프레임 개수만큼 존재
- **기존의 논리 페이지 번호를 보고 페이지 테이블에서 그만큼 떨어진 엔트리에 가는 방법이 불가능**
- 엔트리를 다 검색해서 pid, p가 있는 엔트리를 찾고 물리 주소를 얻는다. => 단점임. 좋은 점은 페이지 테이블의 크기가 줄어든다는 것임.

## Shared Pages (페이지 공유)

![공유된 페이지](/images/os/mm5.png)

- **공유되는 부분을 같은 프레임에, 한 카피만 물리적 메모리에 올림**
- 공유되는 부분: 재진입 가능한 코드Re-entrant code (pure code) 라고 한다.
- shared code의 조건 1: **Re-entrant code는 read-only!**
- shared code의 조건 2: **동일한 logical addr에 위치해야함**

## Segmentation : 프로그램을 의미별로 나눔

- 프로그램은 의미 단위인 여러개의 세그먼트로 구성
- 세그먼트: logical unit (논리적인 단위)
- 작게는 프로그램의 함수 하나하나가 세그먼트일수도, 크게는 프로그램 전체를 하나의 세그먼트로 정의 가능
- 일반적으로 code, data, stack 부분이 하나의 세그먼트로 정의됨
- e.g. main(), function, global 변수, stack, symbol table, arrays, etc.

## Segmentation Architecture

- 논리 주소: ```<segment-number, offset>```
- paging할 때와 비슷하다. offset의 범위 안에 있지 않으면 trap을 발생시킨다.

![세그먼트 하드웨어](/images/os/mm6.png)

### Segment table

- 각각의 테이블 엔트리는 base(세그먼트 물리주소 시작주소)와 limit(세그먼트 길이)를 가짐
- STBR(Segment-Table Base Register), 프로그램이 쓰는 세그먼트의 갯수를 기억하는 STLR(ST Limit Register)
- 페이지 테이블과 다른 점: **limit이 있음. 페이징 기법은 페이지의 크기가 균일해 결국 오프셋 크기=페이지 크기인데 세그먼트의 경우 의미별로 자르는 거라 길이가 다 다르다(offset보단 작아야함). 그리고 페이징 기법은 시작 주소가 프레임 번호면 되는데(물리적 메모리도 같은 크기의 프레임으로 나눠져있기 때문) 세그먼트 기법에서는 베이스 위치로 어디서 프레임이 시작하는지 정확한 바이트 주소를 줘야 하기 때문.**

### Protection

- 각 세그먼트 별로 프로텍션 비트가 있음
- Valid bit가 0이면 Invalid bit

### 공유

- 의미 단위로 자르기 때문에 페이징보다 공유, 보안에 있어 훨씬 효과적임

### 할당 (allocation)

![세그먼트 할당](/images/os/mm7.png)

- segment의 길이가 동일하지 않으므로 가변분할 방식에서와 동일한 문제점들이 발생 (external frag)
- segment의 크기가 각기 달라 hole이 발생하는 게 segmentation의 약점

![세그먼트 공유](/images/os/mm8.png)

## 페이징 + 세그먼테이션

- 세그먼트 하나가 여러개의 페이지로 구성됨. 메모리에 올라갈때 페이지 단위로 쪼개져서 올라감
- 세그먼트 테이블 엔트리가 세그먼트의 base 주소를 가지지 않고! 세그먼트를 구성하는 페이지 테이블의 base 주소를 가짐
- d 오프셋이 세그먼트의 길이 이내여야만 유효함 / **d'는 페이지 안에서 얼마나 떨어져있는지 오프셋**
