---
title: "순차논리와 RAM, 디스크 드라이브와 SSD의 특징"
date: 2022-03-02 08:00
tags:
- 컴퓨터구조
description: 메모리를 알아보고 입출력 장치에 메모리 할당하는 방법을 알아본다. 
---

지난 주에 조합논리를 배웠고 이번 주는 순차논리와 순차 논리 회로들에 대해 이야기했다.

## 조합논리

`출력 = f(입력)`

## 순차논리

`출력 = f(입력 + 저장돼있던 어떤 값)`
이 때 **입력은 현재 상태**, **저장되어있던 값은 과거 상태**를 의미한다.

## **메모리**

: 집이 늘어선 거리(street). 이 집에는 정해진 개수만큼 비트를 저장할 수 있는 방이 있다.  
이 데이터는 데이터 버스에 실어 나른다. (버스: 1개 이상의 장치가 공동으로 사용하는 회선, 회선의 집합)

## RAM (Random Access Memory)

- Random access란? **어느 위치에든 똑같은 속도로 접근하여 읽고 쓸 수 있다**  
- 메모리 배열에 저장된 **행, 열 각각의 주소를 조합해** 읽는다.
- RAM이 8기가라면 8기가 만큼의 공간이 있음. (추상적인 의미가 아님) 
램이 클 수록 공간이 그만큼 넓으니 여러 프로그램을 사용할 수 있는 것.

### SRAM, DRAM (둘 다 휘발성)

|   | SRAM | DRAM |
|---|------|------|
| 구성요소  | 트랜지스터+래치 | 커패시터+소수의 트랜지스터 |
| 속도   | 더 빠름(D램의 100배 이상)| 느리지만 구조가 간단(=> 집적도 향상 쉬움) |
| 가격  | 비쌈 | SRAM 대비 저렴 (cuz 집적도 향상이 쉬움) |
| 용도  | L2, L3 CPU | 컴퓨터 메인 메모리 |
| 데이터 휘발 | 전원 차단시 바로 데이터 지워짐 | 내부에 전류를 일시적으로 저장하는 커패시터가 있어 1주 정도는 보관 가능 |
| 특징   |  | 커패시터와 연결된 스위치가 off되더라도 전류가 새서 메모리 갱신 (재충전) 필요 |

## 블록 장치

블록 장치란 블록 단위로 IO 작업을 수행하는 장치를 말한다. 
디스크 드라이브, SSD, 플래시 메모리가 블록 장치에 속한다.

### 디스크 드라이브

우리가 아는 것처럼 동그란 디스크 판이 회전하면 디스크 헤드가 데이터를 읽는다.

- 디스크 영역을 **자화(자성을 띄도록)** 시켜서 데이터를 저장한다. (비휘발성) 
데이터 알갱이가 자성에 따라 `0` 또는 `1`을 의미하고, 비트를 전류로 변환한다.
- 속도는 **느리지만** 기록의 **밀도가 높고** 주소 공간 필요 없다.
- 블록 단위로만 입출력이 가능해 1바이트만 바꾸고 싶어도 전체 블록을 다 읽고 그 바이트를 바꾼 다음 전체 블록을 다시 써야한다.
- **비트 밀도가 안쪽이 더 높다.** 그래서 최신의 디스크는 외부에 더 많은 섹터를 넣어 낭비를 줄인다.

그러나 디스크 드라이브는 **점점 SSD(Solid State Drive)로 교체**되는 중임

### SSD

: 디스크 드라이브 모양의 패키지에 넣은 플래시 메모리

### 플래시 메모리

- `EEPROM` (전기적으로 프로그래머블, 데이터 삭제 후 재기록 가능)
- 원하는 위치를 맘대로 읽을 수 있음(LIKE RAM)
- 블록 단위로 지우고 씀
- 읽을 때는 임의 접근, 쓸 때는 블록 접근

## I/O 장치 (입출력 장치, 주변장치, peripheral)

: 키보드, 마우스 등 사용자의 입력을 받는 장치와 프린터처럼 출력을 하는 컴퓨터 주변 장치

## 과거: I/O Street과 Memory Street을 분리했다

![과거의 IO 연결](/images/os/io2.jpg)

- 이유 1. 작은 패키지에 우겨넣기엔 컴퓨터가 너무 컸음
- 이유 2. 메모리 Street에 집이 많지 않았어서 IO까지 담기엔 무리였음

## 현재: 메모리 Street의 일부를 I/O 장치에 할당

![현재의 io 연결](/images/os/io1.jpg)

- 이유: 운영체제의 **기본 데이터 처리 단위가 커져서**(32, 64비트) **메모리 거리의 주소 수가 많아짐** ⇒ 빈 집 늘어남

## 입출력 슬롯

컴퓨터에는 표준 입출력 슬롯이 있어 **일관된 방식**으로 IO 장치를 연결할 수 있다.

![io slot](https://t1.daumcdn.net/cfile/blog/0277363D51C2BBE23B)

### 입출력 장치에 메모리를 할당하는 방법 (like 서부시대의 땅 분배)

1. (메모리가?) 빈 집들 중 IO 장치에게 할당할 수 있는 영역(주소들)을 고른다.
2. 각 슬롯의 장치는 자신에게 할당된 주소를 모두 사용 가능하다.
3. 각 슬롯은 CPU가 슬롯-장치 매핑을 할 수 있는 특별 주소를 가진다.

## 입출력 장치 컨트롤러

![IO Controller의 내부 구성도](/images/os/io4.png)

- 프로세서는 이 입출력 컨트롤러의 레지스터에 비트들을 쓰거나 읽음으로써 입출력을 수행

## Memory Mapped IO (메모리 영역에 있는 IO)

![memory mapped io](/images/os/io5.png)

- 오늘날의 대부분
- 메모리, IO가 나란히, 연속된 주소 영역에 할당됨
- IO가 차지하는 만큼 메모리 용량은 감소
- CPU는 메모리, IO를 동일한 외부기기로 간주해 액세스할때 표준 데이터 전송 명령 (**read, write)** 사용
    - Read: IO 장치에서 읽어 오는 것
    - Write: IO 장치를 제어 / 출력
- 소프트웨어적으로도 메모리 액세스 & 데이터 입출력이 동일한 것으로 간주되어 load나 store 명령으로 수행 가능

### 장점

포트 입출력 구현할 때 메모리, io 차이 없어서 CPU 로직이 **간단함** ⇒ 더 저렴하고 빠르고 쉬운 CPU ⇒ **RISC가** 추구하는 바(**‘하드웨어와 기계어 명령어의 단순화 원칙’)**와 일치!

### 단점

주소와 데이터 버스를 더 많이 사용

## IO Mapped IO (IO 영역에 있는 IO)

![io mapped io](/images/os/io6.png)

- Isolated IO라고도 한다. (분리된 IO)
- 메모리, IO가 별개의 주소 영역에 할당됨
- CPU는 이 둘을 구분해야하므로 read/write 외에도 IO에 접근하는 신호(in/out)가 필요함
- 메모리 액세스: load, store
- io 입출력: input, output 명령에 의해 수행됨

### 장점

어드레싱 능력이 제한된 CPU 사용할 때 유리 (메모리 용으로 주소영역 전체를 사용 가능)

### 단점

Memory mapped io 방식 대비 하드웨어 구조가 복잡

## 명령어 비교

![memory-mapped io 의 예시](/images/os/io7.png)

- 데이터 레지스터 주소: 412번지
- 상태/제어 레지스터 주소: 413번지
- 상태 레지스터 최하위비트 = RDY 비트로 사용 (3번째 줄)
- 제어 레지스터 최상위비트 = 프린트 동작 start 비트로 사용 (2번째 줄에서 clear, LOAD 80H에서 load)

---

![io-mapped io의 예시](/images/os/io3.png)

이미지 출처: [https://itstory07.tistory.com/881](https://itstory07.tistory.com/881)
