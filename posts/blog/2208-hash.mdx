---
title: "알고리즘 공부를 시작했다 (프로그래머스 고득점키트 Hash)"
date: 2022-08-01 07:30
tags:
- 알고리즘
- Hash
description: 프로그래머스 고득점키트(1.해쉬)를 자바스크립트로 풀어보았다
---

알고리즘 스터디를 시작하게 되어 [프로그래머스 고득점키트 1. 해시](https://school.programmers.co.kr/learn/courses/30/parts/12077) 를 풀어보았다. 부끄럽지만 알고리즘 공부를 이제서야 시작한다. 은이의 알고리즘 성장기 함께 하시죠...ㅎ 🥰

## PREP
알고리즘 문제를 풀때 [PREP 을 작성해보면 도움이 된다고 한다.](https://m.blog.naver.com/guangaae/222763880700)
`PREP`이란 Parameter, Return, Example, Pseudocode다.

**문제에서 주어지는 파라미터**와 **내가 구현해야하는 리턴값**을 생각하고, 예제로 **내가 문제를 제대로 이해했는지 확인**하고, **의사코드**로, 간단하게 짜본다.

참고로 1시간 안에 문제를 못 풀 경우엔 그냥 다른 사람의 풀이를 보고 공부하였다.

## 1. 폰켓몬
P: nums (배열)
-   고를 포켓몬 수 (제한): `nums/2`
R: 가장 많은 종류의 포켓몬을 선택했을 경우, 선택된 종류 수

### 풀이과정
=> **포켓몬의 종류 수가 nums/2보다 크면 nums/2**가 되고 **포켓몬의 종류 수가 nums/2보다 작으면 포켓몬의 종류 수**다.

```js
// 내가 짠 코드
function solution(nums) {
    var answer = 0;
    let pkmKindMap = new Map() // hashmap object
    for (let i of nums) {
        let iCnt = pkmKindMap.get(i)
        if (iCnt) { // 맵 안에 포켓몬이 이미 있을 경우 맵에서 cnt+1    
            pkmKindMap.set(i, iCnt+1)
        } else {    // 포켓몬이 없을 경우 맵에 새로 추가
            pkmKindMap.set(i, 1)
        }
    }

    // 포켓몬 종류 수 합 구하기
    let pkmKindCnt = pkmKindMap.size
    if (pkmKindCnt >= nums.length/2) {
        return nums.length/2
    } 
    return pkmKindCnt
}
```

```js
// 다른 사람의 풀이
// 가독성 있게 max를 변수로 만들어두고
// Set가 중복제거된 자료구조인 것 & JS 스프레드 문법이 핵심인 듯!
function solution(nums) {
  const max = nums.length / 2;
  const arr = [...new Set(nums)];

  return arr.length > max ? max : arr.length
}
```

### 깨달은 것 / 배운 것
- 포켓몬당 수를 저장할 필요 없는데 나는 그걸 `Map`에 정리했다. 자원을 낭비한 셈이 된다. 핵심을 생각하자. 
- `set`가 중복 제거를 해주는 자료구조라는 걸 기억하자

## 2. 완주하지 못한 선수

P: **마라톤에 참여한 선수들의 이름이 담긴 배열** `participant`와 **완주한 선수들의 이름이 담긴 배열** `completion`
R: 완주하지 못한 선수의 이름

```js
// 같은 이름의 선수가 있다고 해서 
// 참여자 맵, 완주자 맵에 {이름:수}를 넣어
// 이름에 대한 사람 수가 다른 걸 찾았음
function solution(participant, completion) {
    let participantMap = new Map();
    let completionMap = new Map();
    let giveUpArr = []

    for (let person of participant) {
        let prevCount = participantMap.get(person) ? participantMap.get(person) : 0
        participantMap.set(person, prevCount+1)
    }

    for (let person of completion) {
        let prevCount = completionMap.get(person) ? completionMap.get(person) : 0
        completionMap.set(person, prevCount+1)
    }

    for (let [person, cnt] of participantMap.entries()) {
        let passPersonCnt = completionMap.get(person) ? completionMap.get(person) : 0
        // 완주 안 한 사람이 있으면
        if (passPersonCnt < cnt) {
            giveUpArr.push(person)
        }
    }
    return giveUpArr[0];
}
```

```js
// 다른 사람의 풀이
// 사람 이름에 중복이 있으므로 각각 sort() 
function solution(participant, completion) {
    participant.sort();
    completion.sort();

    for(let i in participant) {
        if(participant[i] !== completion[i]) return participant[i];
    }
}
```

### 깨달은 것, 배운 것
- 안전빵으로 for문을 여러번 썼는데... 다른 사람의 풀이처럼 `sort()`를 해서 비교하면 한 번에 다른 부분을 캐치할 수 있었다. 다음부턴 이런 경우에 `sort()`를 우선적으로 고려하고, for문을 여러번 하는건 정말 최후의 보루라고 생각하자.

## 4. 위장 (못 품)
P: `clothes` 2차원 배열 
R: 서로 다른 옷의 조합의 수

### 풀이과정
-   의상의 종류 map
-   반복문을 돌면서 clothes[1]의 값이 의상 종류map에 있는지 확인
-   의상종류 map 안에 있으면 +1, 없으면 map을 새로 추가

```js
// 다른 사람의 풀이 1 
// educe으로 배열을 롤리고 3번 라인에서 각 종류에 따라 분류, 5번에서 경우의 수를 찾아 반환
// 객체에 {부위명: 부위명에 속한 옷 갯수} 형태로 갯수를 누적시킨다음, 그 갯수들을 + 1 한 값으로 모두 곱한 후 최종 -1 하여 리턴
function solution(clothes) {
    return Object.values(clothes.reduce((obj, t)=> {
        obj[t[1]] = obj[t[1]] ? obj[t[1]] + 1 : 1;
        return obj;
    } , {})).reduce((a,b)=> a*(b+1), 1)-1;    
}

// 다른 사람의 풀이 2
// 옷 카테고리별로 경우의 수에 + 1 (아예 안입는 경우의 수)를 해서 다 곱해버린 다음 
// (answer = answer * (파츠별 경우의 수 + 1)) 아무것도 안입었을 때의 경우의 수 1개를 빼기 때문에,
// 1을 더하면서 다 곱한 후 answer - 1 을 리턴
function solution(clothes) {
    let answer = 1;
    const obj = {};
    for(let arr of clothes) {
        obj[arr[1]] = (obj[arr[1]] || 0) + 1;
    }

    for(let key in obj) {
        answer *= (obj[key]+1);
    }

    return answer - 1;
}
```

## 5. 베스트앨범 (못 품)
```js
// 다른 사람의 풀이

function solution(genres, plays) {
    var dic = {};
    genres.forEach((t,i)=> {
        dic[t] = dic[t] ?  dic[t] + plays[i] :plays[i];        
    });

    var dupDic = {};
    return genres          
          .map((t,i)=> ({genre : t, count:plays[i] , index:i}))
          .sort((a,b)=>{               
               if(a.genre !== b.genre) return dic[b.genre] - dic[a.genre];
               if(a.count !== b.count) return b.count - a.count;
               return a.index - b.index;
           })
           .filter(t=>  {
               if(dupDic[t.genre] >= 2) return false;
               dupDic[t.genre] = dupDic[t.genre] ? dupDic[t.genre]+ 1 : 1;
               return true;
            })
           .map(t=> t.index);    
}
```